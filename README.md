# CS300

In this course, I tackled two main problems: analyzing how different data structures perform in terms of run-time and memory and implementing a course planner that can sort and display course information. I approached the first problem by evaluating vector, hash table, and binary search tree (BST) implementations, carefully breaking down their complexity and tradeoffs. I found the BST to be the most effective, offering both efficient lookups and built-in ordering. For the second project, I used a C++ map to store courses and sort them alphanumerically, ensuring the output met the specification. One major roadblock was validating prerequisite references and designing a clean, user-interactive CLI, which I resolved by separating logic into functions and using STL containers. These projects expanded my understanding of when and why to use specific data structures, especially for applications involving ordering and fast retrieval. It also changed how I write software. I now think more carefully about modularity, user interaction, and how to keep my code readable and adaptable for future use.
